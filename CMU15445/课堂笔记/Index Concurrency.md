
锁的种类有阻塞式的系统锁，自旋锁
系统锁将对线程进行休眠-唤醒操作，需要从用户态陷入内核态，上下文切换开销大。但是休眠的这段时间中，不占用系统资源
而自旋锁结合atomic实现，将不断地检测锁资源是否被释放，这同样也是一个消耗系统资源的操作。但是线程不用陷入内核态，没有上下文切换

编程语言通常将这两种锁结合，Java中的锁，会先自旋再休眠(使用系统锁)

hash table的加锁较好实现，因为所有线程的加锁方向都是相同的，从上往下
从header page->directory page->bucket page，加锁方向一致不会导致死锁问题

B+ tree的并发保护分为两点：
- 分裂/合并操作时，对分裂/合并的node进行保护
- 多个线程访问同一个node时，对node进行保护

latch crabbing/coupling: 像螃蟹一样加锁，每次加锁都加**一对**
给父节点加锁，再给子节点加锁
然后判断父节点是否能解锁，若能解锁，就往下走

那么如何判断锁了下面的，在什么情况下能解上面的？
不会触发分裂/合并

find：锁子节点的读锁，解父节点
insert/delete：
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/202408080953579.png)

每次上的螃蟹锁，都是写锁。将导致根节点的资源竞争严重。用乐观的心态，给给螃蟹锁加读锁，最后要修改时再对node加写锁
如果修改触发了分裂/合并，那么需要从根节点开始一路上写锁，给螃蟹锁的种类替换成写锁