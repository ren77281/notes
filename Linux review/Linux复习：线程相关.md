```toc
```

## Q&A
***
### 线程概念

#### Q：线程和进程的区别？（为什么要有线程，从进程的角度说明这个问题）
A：Linux用task_struct结构体描述一个进程，可以说进程 = task_struct + 内存中的数据与代码。而task_struct包含了进程页表、进程地址空间等资源，创建一个进程就需要为它分配这些资源。值得思考的是：分配资源本身就需要消耗资源，进程是否能充分利用分配得到的资源？而且由于进程具有独立性，进程间想要共享或发送数据，就要进行进程间通信，但通信的成本过高，会消耗过多资源，降低系统的性能。

若操作系统只有进程，那么进程就是系统的基本执行流。

- 要执行不同的程序，就要创建新的进程，但是创建进程会带来资源的消耗，这是其一
- 若一个进程要使用另一个进程的数据，就要进行进程间通信，通信的代价也是额外资源的消耗，这是其二

为解决以上两个问题（*最主要的两个*），线程被引入，线程作为进程的一部分，和进程共享进程地址空间（*资源*），同时解决了进程间通信与反复创建进程带来的资源消耗问题。

#### Q：Linux是如何设计线程的？
A：学习进程时，我们说：进程 = task_struct + 内存中的数据与代码，这个说法默认了task_struct是进程控制块，也就是说task_struct是为了进程而设计的结构。但是事实并不是这样，准确的说task_struct是Linux中的一个执行流。若一个进程下没有线程（*或者说唯一的线程就是自己*），此时的进程就是一个执行流。若一个进程下有多个线程，此时的进程就不再是执行流，此时的执行流是进程下的线程，进程是多个执行流的集合。

所以task_struct即不是为进程设计的，也不是为线程设计的，它是为执行流这个概念设计的，你也可以极端点，认为Linux下没有进程与线程的概念，Linux只有执行流的概念。提出进程和线程只是为了更好的理解操作系统。

回到问题，你可以认为Linux只有执行流的概念，它对应的结构体为task_struct。但是为了使多个执行流可以**同时使用相同的资源而不冲突**，Linux肯定是要对线程进行设计的。我们可以通过if else判断fork的返回值，控制父子进程，使两进程分别执行不同的代码块（*函数*），从而使它们的函数栈分离，体现在进程地址空间上，两进程就是使用了不同的空间。这样的思想也体现在线程的设计中，Linux设计了thread_struct结构体，其中有一组变量维护了寄存器地址，这些寄存器则维护了一个函数栈。所以，每个线程都享有一个独立的函数栈（*地址空间*），这样就解决了线程间数据冲突的问题。
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230412210518.png)

总结一下：Linux用thread_struct结构体表示线程结构，该结构体中最重要的是一组寄存器地址，这些寄存器维护了线程的函数栈，使线程享有独立的资源，互不冲突。

#### Q：学习了线程后，你能说说进程和线程最大的区别是什么吗？
A：两者最大的区别就是：承担的职责不同
- 进程是系统中资源分配的基本单位，系统分配进程地址空间、页表等结构，消耗了大量资源
- 线程是系统中调度的基本单位，系统分配资源给进程，线程使用进程的一部分资源，以执行任务
***
### 进程和线程的比较

#### Q：线程使用进程的资源，它们之间的所有资源都是共享的吗？有哪些资源不是共享的？
A：
- 线程独享的资源
1. 线程ID：需要用不同的线程ID标识同一进程下的不同线程
2. 一组寄存器与函数栈：为了防止线程之间发送数据冲突，线程需要维护自己的函数栈
3. errno：每个线程必须独享errno以便在程序崩溃时更快定位错误
4. 信号屏蔽字：每个线程可以设置自己想要屏蔽的信号
5. 调度优先级：可以设置线程的优先级以调整线程的执行顺序

- 线程与进程共享的数据
1. 文件描述符表：线程和进程打开的文件，彼此都能看到
2. 信号的递达方式：线程和进程设置的信号递达方式也会彼此影响
3. 当前工作路径：进程与使用其资源的线程在同一工作路径下运行
4. 用户id和组id：进程与使用其资源的线程拥有相同的owner和group
5. 全局内存、堆、栈资源：由于线程使用进程的页表，这些资源当然是共享的

#### Q：线程的优缺点分别是什么？
A：
- 优点：
1. 充分使用进程的资源，尽可能的减少不必要进程的创建，提高系统性能
2. 线程之间数据共享，比起进程间通信，这是一种更高效的通信方式
3. 创建线程的代价小于进程，因为系统不要为线程分配页表、进程地址空间这样的资源
4. 切换线程的代价小于进程，因为系统不需要重新加载页表、进程地址空间，只需要重新加载task_struct结构体以及线程的函数栈
5. 充分利用多处理器的可并行数量
6. 在含有慢速IO的进程中，可以创建线程等待慢速IO的结束，使进程可以执行其他任务，不必等待慢速IO的结束
7. 在密集IO的进程中，可以创建多个线程等待IO的结束，使等待时间重叠，有效提高了程序的运行效率

- 缺点：
8. 健壮性较差：线程崩溃退出会导致进程的退出
9. 调试难度大：多线程程序下的错误难以定位

***
### 线程操作

#### Q：线程终止的三种方式分别是什么？
A：
1. 直接return，不过返回的对象要强转为(void*)
2. 调用int pthread_exit(void\* retval)退出，该函数的参数是一个类型为void\*的变量
3. 调用int pthread_cancel(pthread_t thread)向指定线程发送cancel信号，该线程的返回值为-1

#### Q：为什么pthread_self()的返回值和LWP不一样？
A：LWP（light weight process），轻量级进程，使用ps -aL可以查看线程的LWP。而pthread_self()的返回值（*线程ID*）远远大于LWP，其原因是：
- Linux没有提供线程的操作接口，或者说这些接口不够简便，需要自己设置于管理线程的属性。我们的线程操作基于第三方库，第三方库帮助我们设置与管理线程的属性
- 第三方库使用struct thread_info结构体存储线程的信息，而这些结构存储在进程地址空间的**共享区**，线程ID的值就等于这些结构体的首地址
- 可以通过程序验证，线程ID的值小于栈区地址，大于堆区地址
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230413133904.png)

- LWP是内核的一个概念，内核用LWP对轻量级进程进行管理
- 线程ID是地址空间的一个概念，通过线程ID可以找到线程的属性，从而对线程进程管理（*这是我们通过线程库对线程的间接管理*）

#### Q：为什么要进行线程分离？
A：主线程创建的子线程默认具有joinable属性，若主线程不主动join子线程，会造成资源泄漏与线程句柄的耗尽。线程分离后，主线程不用join子线程，子线程结束，其资源会自动释放。

这个问题也能理解为：为什么要join子线程？两个原因：一个是回收子线程的资源，一个是得到子线程的返回值，前者是必要的，而后者是非必要的。当主线程不再关心子线程的返回信息时，主线程可以主动分离该线程。

#### Q：为什么要由主线程分离子线程？不能子线程自己分离？
A：这是为了防止一些bug的产生，也是一种编程规范。若子线程调用pthread_detach分离自己，主线程无法确定子线程什么时候被分离，如果主线程在在子线程调用pthread_detach之前调用pthread_join该线程，那么主线程会陷入阻塞，但由于该线程被分离，不会向主线程返回，所以主线程会陷入永久的阻塞，程序因此产生bug。

所以不能让子线程调用pthread_detach分离自己，这会带来一些不确定性。同时我们也要确保主线程不要对将要分离或已经分离的子线程做任何操作。
***
### 线程互斥

#### Q：什么是临界资源？临界区呢？
A：由于进程下的线程共享同一进程地址空间，对于进程下的共享资源，每个线程都可以低成本的访问。但由于线程并发的存在，多线程同时访问共享资源可能造成数据不一致的问题，进而导致严重的bug。而解决这一问题的方法是：将共享资源转换成临界资源，当一个线程访问临界资源时，其他线程无法访问。也就是说，临界资源是同一时刻只允许一个线程访问的资源。而访问临界资源的代码块就被成为临界区。

#### Q：什么是互斥？
A：同一时刻只允许一个线程访问的资源，我们称该资源具有互斥性。临界资源具有互斥性。

#### Q：数据不一致的本质是什么？
A：线程访问共享资源时，相关操作不是原子操作！也就是不具有原子性。线程对共享资源的操作执行一半时，就被操作系统切走，在该线程重新被调度之前，其他线程对该共享资源的操作无效。

#### Q：用锁对共享资源进行保护的前提是：锁也要作为共享资源被其他线程使用。那么用锁保护共享资源的本质是：用共享资源保护共享资源，这合理吗？
A：首先，锁确实是一个共享资源。但是多线程并发访问共享资源带来的数据不一致问题的本质原因不是：该资源是否是共享资源，而是：访问共享资源的操作是否具有原子性！我们对mutex的所有操作都是原子的，即使mutex是一个共享资源，但原子操作可以保证其数据一致，不会出现错误。也就是说，pthread线程库将所有mutex的操作设计成原子操作，以保证mutex的绝对安全。

#### Q：lock的原子操作是怎样实现的？
A：
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230414122943.png)
这是上锁过程的伪代码。简单理解一下代码
- movb $0, %al：将0加载到al寄存器中
- xchgb %al, mutex：将al寄存器的内容与mutex交换。mutex是锁的一个变量，其值为1
- 判断al寄存器的值是否为0。
  - 若不为0，则lock成功
  - 若为0，则lock失败，线程被挂起
- 当线程被唤醒后，会重新执行一次lock

其中的关键是xchgb这条指令，这是一个由内核实现的原子操作，也就是说交换过程要么已经完成，要么没有发生。正是xchgb的原子性，整个lock接口也具有了原子性。

一把互斥锁只有一个值为1的mutex变量，线程想要上锁就要加载0到寄存器，将0和mutex进行交换。而0很廉价，每个线程都能有0，都拿着0与互斥锁的1进行交换，但是一旦1被某个线程交换走，其他线程交换得到的就是被用来交换的0了。而只有交换得到1的线程才能lock成功，其他线程会陷入阻塞，并且被唤醒后会重复这一过程（*直到al寄存器交换到1为止*）。

这就是lock上锁的过程，其中有一个问题，如果al寄存器一直交换到0，那么调用lock的线程就会不停的重复这个过程。这样的现象叫做死锁。

#### Q：死锁的四个必要条件是什么？如何避免死锁？
A：
1. 互斥条件：多线程并发访问共享资源，但同一时刻只允许一个线程访问临界资源
2. 不剥夺条件：除非持有锁的线程自己释放锁，否则其他线程无法剥夺该线程持有的锁
3. 请求与保持条件：持有锁的线程继续请求其他锁资源，若因此陷入阻塞，其他线程一定无法获取其持有的锁资源
4. 循环等待条件：线程之间请求锁的请求关心构成循环。最简单的循环就是A和B两个线程同时请求对方持有的锁资源，此时双方都陷入阻塞，构成了死锁

- 破坏以上四种关系中的任意一种即可避免死锁，一般情况下，我们只能破坏条件三和条件四
- 加锁顺序一致与资源一次性分配：破坏循环等待条件，减小线程占用彼此锁资源的概率
- 及时释放锁资源：破坏请求与保持条件。加锁的粒度越细越好，这不仅是为了提高程序的运行效率，也是为了避免死锁
***
### 可重入与线程安全？

#### Q：什么是可重入？它与线程安全的关系是什么？
A：可重入是指：可以在被中断后继续执行（*重复进入*），并且不会发生错误的函数或者代码段。比如线程A正在调用某一函数或者代码段，调用到一半被cpu切走，此时线程B也调用了该函数（*也可以不调用该函数，只是正常的运行*）。当cpu恢复线程A时，线程A继续执行代码且执行完成后，程序不会发生错误（*数据不一致，内存泄漏*），此时我们称该函数或者代码段具有可重入性。

线程安全是指：在多线程并发的场景下，程序不会出现数据/结果不一致的情况。这些情况多发生在线程访问静态变量与全局变量（*共享资源*）时。

可重入的函数/代码段一定是线程安全的，但线程安全的程序中，函数/代码段不一定是可重入的，因为它可能添加了访问控制。

需要注意的是：可重入与不可重入没有优劣之分，它们只是区分代码的两个性质。若要实现线程安全，可以对不可重入的代码添加访问控制。本质就是建立临界区，保护共享资源。