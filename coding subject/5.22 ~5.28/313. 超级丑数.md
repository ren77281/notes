[313. 超级丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/super-ugly-number/)
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230527161824.png)

和丑数那题一样，只是这题的质因数数量不固定。
用动态规划，根据质因数与之前的丑数，每次确定一个最小的丑数
倒是不能无脑set更新，因为你不知道什么时候停下来合适

题目给定一个质因数数组，需要做的是：将每个质因数与已经推导出的丑数相乘，得到新的丑数。
`uglys[i]`表示第i个丑数
要更新`uglys[i]`，不是从`uglys[i - 1]`推导，而是从之前的丑数推导
一开始的丑数为1，要推导第二个丑数，需要将1乘以质因数数组，得到一个最小的丑数，该数就是`uglys[i]`。可以注意到刚才的推导是：将1乘以质因数数组，后续的推导还是这样吗？需要保证这个乘积的结果是未推导过的丑数，得到多个未推导过的丑数，选择其中最小的一个作为下一个丑数。

所以，与每个质因数相乘的丑数需要更新。如果一个质因数乘以一个已推导过的丑数，还是得到一个已推导过的丑数，那么该与该质因数相乘的已更新的丑数就需要更新。

这里用下标表示uglys数组中，与质因数相乘的丑数。由于质因数的个数不确定，所以需要根据质因数的个数来确定下标的数量。这里用vector存储这些下标，一开始这些下标是0，表示所有质因数都是1相乘，因为得到的丑数都是未推导过的丑数。

之后只要推导出一个丑数，就需要检查每个质因数和对应丑数相乘，是否得到了已推导过的丑数。若得到了已推导过的丑数，该质因数对应的丑数就需要更新，更新只要用下一个丑数代替原丑数即可。
之前说过这里用下标数组表示与质因数相乘的丑数，所以只要将数组中的下标++即可。
```cpp
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        int m = primes.size();
        vector<int> idx(m, 0);
        vector<long long> uglys(n, 0x7FFFFFFFFFFFFFFF);
        uglys[0] = 1;
        for (int i = 1; i < n; ++i)
        {
            for (int j = 0; j < m; ++j)
            {
                uglys[i] = min(uglys[i], primes[j] * uglys[idx[j]]);
            }
            for (int j = 0; j < m; ++j)
            {
                if (primes[j] * uglys[idx[j]] == uglys[i])
                    idx[j]++;
            }
        }
        return uglys[n - 1];
    }
};
```

果然，梳理了一遍思路，直接写出来了。

原来这种方法还叫“多路归并”啊。当前丑数序列乘以质因数中的一个，得到的序列依然数丑数序列。将当前序列乘以一个质因数的结果看成一个链表，本题就变成了合并多个有序链表。即多路归并，所以说这题不是动态规划，更应该叫多路归并
***
至于说，为什么可以用下一个丑数替换原丑数这样的更新方式，