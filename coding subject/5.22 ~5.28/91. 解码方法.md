[91. 解码方法 - 力扣（LeetCode）](https://leetcode.cn/problems/decode-ways/)
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230515182049.png)

输入的是一串字符，需要做的是将其映射为字母，字符和字母有着1~26的直接映射。需要注意的是前导0，比如01，02不能视为1，2，并将其映射。

确定状态：dp\[i]表示字符串的前i个字符解码得到的序列的总数，所以最后返回dp的最后一个成员即可
状态转移方程：从dp\[i - 1]到dp\[i]，问题是新的字符与其前面的字符是否能够解码？将新字符单独解码肯定是可以的，若其与之前的字符也能解码，那么能解码的总数+1。
而一个字符串，将所有字符单独解码，就能得到一种解码方式。所以dp\[0]一开始为1，当新字符与其之前的字符也能解码，dp\[i] = dp\[i - 1] + 1
需要注意的是：前导0，如果新加入的字符是0，0与其之前的字符作为整体进行映射，此时正常判断，因为此时的0不是前导0。当新字符之前的字符是前导0，那么不进行后续判断，dp\[i] = dp\[i - 1]。
所以到字符串第一个字符为0时，该字符串不能解码，因为只有当0作为后缀时才有意义。所以此时直接返回0

哦不对不对，因为0不能被单独解析。当0作为后缀时，只有和前缀的整体能解码时，dp\[i]将不变，因为0不能被解码。如果其与前缀不能被解码，那么将直接返回0
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230515184640.png)

这么看来，当字符串中出现了0，就表示起始状态不是1，即单独解码字符行不通

这里重新梳理一遍：第一个字符为0，整个字符串不能解码，直接返回0
当字符串中有0，不能单独解析每个字符，初始状态为0，否则为1
如果0作为后缀且能和前缀一起被解析，sum要+1，如果0作为前缀，那么字符串显然不能被解析，sum不变

还是不对。。。

0作为后缀时，若能和前缀一起被解析，两者是绑定在一起的。即前缀不能作为其他字符的后缀
***
重新梳理一下思路，该题需要将数字1~26映射为字母，需要注意前导0不能被映射。

状态确定：`dp[i]`表示前i个字符中，最多的解码方法
状态转移：`dp[i - 1]`如何推导到`dp[i]`？若第i个字符能够被解析，那么`dp[i - 1]` = `dp[i]`。两个状态的解码方法一样，若第i个字符和i-1个字符也能够被解析，那么`dp[i]` = `dp[i - 2]`。若两者都无法解析，那么可以直接返回false了。因为字符串中存在无论如何都无法解析的字符
只要第i个字符不是0，那么`dp[i]` = `dp[i - 1]`，重点是`dp[i]`要不要加上`dp[i - 2]`？

初始状态：先更新第一个和第二个字符，`dp[0]与dp[1]`
```cpp
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0')
            return 0;

        int n = s.size();
        vector<int> dp(n + 1, 0);
        dp[0] = dp[1] = 1;

        for (int i = 2; i <= n; ++i)
        {
            if (s[i - 1] != '0')
                dp[i] += dp[i - 1];
            if (s[i - 2] != '0' && (s[i - 2] - '0') * 10 + s[i - 1] - '0' <= 26)
                dp[i] += dp[i - 2];
        }
        return dp[n];
    }
};
```
这题的初始状态很烦，若`dp[0]`表示前一个字符的解码总数，要更新dp数组，就要表示出`dp[1]` 。