```toc
```
## 语言
### volatile关键字
先介绍作用：修饰变量，用于告诉编译器，该变量的值可能在程序外部被改变，防止编译器将变量的值优化到缓存或寄存器中，每次都从内存访问变量，以读取最新值。

再介绍场景：
1. 在多线程环境中，修饰共享变量，确保对共享变量的读写操作有效，不会被编译器优化掉。
2. 在信号处理函数中，确保对变量的修改能够被正确的读取。
3. 在嵌入式设备的程序中，硬件设备的寄存器值可能随时发生变量，用volatile修改寄存器值，确保每次访问都获取最新值。

总结：总的来说volatile保证了内存可见性。

### 谈谈malloc的底层实现
malloc用于动态分配指定大小的内存资源。通过brk/mmap系统调用获取内存块，并返回合适内存块的指针，并用链表维护空闲的内存块。

具体来说：malloc会先访问空闲链表，返回合适大小的内存块。如果不存在合适的内存块，将进行系统调用。

brk用于调整调整数据段的结束位置，从而扩展/缩小可用的堆内存。分配的内存连续，常用于小块的内存分配。

mmap映射任意大小的内存区域，适用于大块的内存分配，可以减少内存碎片，但开销大于brk。

系统调用获取的内存资源可能超出实际需求，malloc将多余内存拆分，并加入到空闲链表中。对于每个返回的内存块，都存在一个元数据区域，存储块的大小信息，便于free的内存释放。

此外，malloc会将内存对齐至特定的边界，如8，16字节，以提高缓存命中率，减少内存访问次数。

### 引用和指针的区别
引用是已存在对象的别名，必须初始化且无法更改。指针是存储对象地址的变量，可以为空也可以指向不同对象。

引用不占用额外的内存，不需要解引用操作，访问引用就是访问原对象。

指针常用于实现数据结构（链表，树），以及运行时需要改变指向的场景。

### C++11的新特性
1. 智能指针
2. lambda
3. 右值引用与移动语义
4. tuple容器，存储不同类型的元素
5. 语法糖：范围for，底层是基于迭代器的遍历
6. 关键字：constexpr，用来在编译其计算表达式

### C++的内存管理，和C语言对比
先回答进程的内存区域有哪些：从低地址到高地址分别是：代码区、全局数据区、堆区、共享区、栈区。

再回答C++的new和delete：new和delete作为C++的关键字，分别用来申请和释放堆区的内存资源。如果要申请数组资源，需要在关键字后加上中括号。

最后提一嘴智能指针：从C++11开始，可以使用智能指针：shared_ptr和unique_ptr管理堆区资源，避免内存泄漏。

### 介绍智能指针
先概括要点：unique_ptr和shared_ptr是C++11引入的智能指针，利用RAII来自动管理堆区资源。具体的说，创建对象时，申请资源。当对象的生命周期结束时，释放资源。

再分别细说：

unique_ptr独占资源所有权，不可拷贝，只能被移动。通常用于确保一个对象只有一个所有者的场景。

shared_ptr共享资源所有权，多个shared_ptr可以指向同一个对象。使用引用计数跟踪对象的生命周期，当最后一个shared_ptr的生命周期结束时，资源才会被释放。

但是shared_ptr会造成循环引用问题。

### shared_ptr的循环引用问题
描述问题：当两个对象互相持有指向对方的shared_ptr，并且这两个对象的资源由shared_ptr管理。将导致引用计数无法清零，对象的析构函数永远不会被调用，内存无法释放。

解决方法：使用weak_ptr代替任意一个shared_ptr，weak_ptr不会增加引用计数，从而打破循环。

### C++四种类型转换
- static_cast：用于基本类型之间的类型转换，不进行运行时的类型检查
- dynamic_cast：用于继承体系中父子指针的类型转换，在运行时进行类型检查，失败返回nullptr
- const_cast：用于添加或去除变量的const属性
- reinterpret_cast：用于不同类型之间的转换，不进行运行时的类型检查，和C语言的类型转换相同，重新解释一个变量，这是一个危险的类型转换

### 什么是多态
多态是面向对象编程中的一个重要特性，不同对象对同一接口表现出不同行为。

主要分为静态多态与动态多态：静态多态通过函数重载与运算符重载实现，在编译时确定函数调用。动态多态通过虚函数实现，父类的指针或者引用调用虚函数时，根据对象的类型调用相应的方法，在运行时确定函数调用。

### 谈谈虚函数
先简要概述：虚函数是实现运行时多态的一个机制。子类重写父类的虚函数，在运行时根据对象的类型选择合适的函数调用。

再展开说明：用virtual修饰的成员函数就是虚函数。通过父类指针或引用调用虚函数时，程序会根据对象的虚函数表决定需要调用的函数，这种行为叫做动态绑定。具体来说，子类向父类继承虚函数表，虚函数表指向了函数所在的地址。如果子类重写父类的虚函数时，将用新的函数地址覆盖原函数地址，所以重写也称为覆盖。

最后说明虚函数的开销：但是虚函数表的维护以及通过表查找函数将带来额外的运行时开销。

总之，虚函数使程序更加灵活，但带来了额外的开销。

### 为什么有些类的析构函数设计成虚函数？
确保父类指针或引用在删除子类对象时，能够正确调用子类的析构函数，防止子类部分的资源泄漏。

### 虚函数表存储在哪？
编译器会为每个具有虚函数的类生成一张虚函数表，程序在加载类时将生成虚函数表并存储在全局数据区。每个包含虚函数的对象有一个隐藏的虚指针，指向了全局数据区的虚函数表，虚指针存储在栈区/堆区。

### 虚函数可以被声明为内联吗？
不能。内联需要在编译期间确定函数调用，并展开函数。而虚函数的函数调用在运行时确定。因此，编译器无法展开一个虚函数。

## STL相关
### STL常见容器的实现与特点
vector：动态数组。使用连续的内存块存储元素，支持快速的随机访问。扩容时会重新分配更大的内存，并复制现有元素。除了尾部元素的插入与删除，其他位置元素的插入与删除都会导致部分元素的移动，效率较低。

list：双向链表。使用非连续的内存块存储元素，不支持随机访问。适合频繁的插入/删除操作。

set/map：基于红黑树实现，保证元素有序，插入/删除/查找的时间复杂度是$O(logN)$

unordered_set/unordered_map：基于哈希表实现，元素无序，插入/删除/查找的平均复杂度是$O(1)$

### STL容器存在哪些迭代器失效的问题？
首先说明迭代器失效指的是：迭代器指向了不同元素或者未知元素，继续访问失效的迭代器是未定义行为，可能导致程序的崩溃。

- vector, deque, string：
  - 插入将导致指向该元素以及后续元素的迭代器失效。如果触发了扩容，将导致所有的迭代器失效。
  - 删除将导致指向该元素以及后续元素的迭代器失效
- list, set, map：
  - 插入元素不会导致任何迭代器失效
  - 删除元素只会导致被删除元素的迭代器失效
- unordered_set, unordered_map：
  - 由于底层是哈希表，插入元素可能导致分裂rehash，使得所有元素的迭代器失效
  - 删除元素只会导致被删除元素的迭代器失效，但可能导致合并rehash使得所有元素的迭代器失效


## Linux系统
### 常见Linux系统命令
1. 基础文件操作：ls, cd, pwd, mkdir, touch, mv, cp, rm
2. 资源相关：ps, top, df, tar
3. 查看相关：find, grep
4. 传输文件：scp

### 可执行程序如何产生？
从编译+链接两个方面去回答，分为四个方面：
1. 编译：编译器将源程序翻译成目标代码，通常生成.o文件
2. 链接：链接器将目标文件和依赖的库文件组合在一起，解决符号引用，生成最终的可执行文件
3. 加载：操作系统将可执行文件加载到内存，并为其分配必要的资源
4. 执行：CPU开始执行内存中的指令，程序正式运行

### 对操作系统的理解

操作系统在应用和硬件之间提供抽象和管理，确保系统能高效运行。主要职责有：
1. 资源管理：分配管理CPU、内存、磁盘等资源
2. 进程管理：调度进程的资源，多进程的并发
3. 内存管理：通过虚拟内存机制，为应用分配内存资源
4. 文件系统：管理文件的存储与访问
5. 设备驱动：控制硬件设备，提供统一接口

### 进程和线程的特点
进程：
- 资源分配的基本单位，拥有独立的内存空间
- 进程间隔离，通信开销大
- 切换开销大，需要保存许多的上下文信息
线程：
- 进程内的执行单元，任务调度的基本单位
- 同一进程下的线程共享进程资源，通信开销大
- 切换成本低

最后总结：线程是轻量级进程，多个线程可以并发执行，提高程序效率。
### 谈谈多进程与多线程
多进程：
- 每个进程独立运行，资源隔离性强，适合处理CPU密集型任务
- 进程间通信复杂，切换开销大， 系统资源占用多
多线程：
- 线程共享进程内资源，切换开销低，适合I/O密集型任务
- 线程间通信简单，需要同步互斥机制避免资源竞争

### 为什么多进程适合CPU密集型任务？
首先回答CPU密集型任务：CPU密集型任务依赖CPU的算力，持续的计算占用了大量的CPU时间。

再回答多进程的优点：
1. 多进程的资源竞争带来的性能消耗少
2. 可以充分利用多核CPU的性能，实现真正的并行
3. 进程具有隔离性，一个进程的崩溃不会影响其他进程，系统整体的稳定性更高

### 为什么多线程适合I/O密集型任务？
首先I/O操作的时间长，将导致CPU的等待，浪费CPU资源。

1. 利用线程的并发性，让一个线程等待I/O操作，其他线程继续执行，提高整体效率
2. 线程并发时，切换的开销低，能有效利用CPU空闲时间
3. 线程的通信成本低，利用传输I/O结果

### 谈谈读写锁与互斥锁
首先锁是用于多线程同步的一种机制，读写锁与互斥锁的使用场景与性能不同。

1. 互斥锁作为独占锁，所有线程必须依次获取锁。这是绝对的串行化调度，任何时刻都只有一个线程能持有锁，适用于需要完全排他的场景
2. 读写锁分为读锁与写锁，对于读锁：只要没有线程持有写锁，多个线程能同时持有读锁。对于写锁，线程持有写锁时，其他线程无法获取读锁与写锁

再谈性能对比：
- 在读多写少的情况下，读写锁的性能由于互斥锁，因为读操作可以并行
- 在写操作频繁的情况下，读写锁的性能优势不够明显，可以考虑用互斥锁完成简单的同步


## 计算机网络

### 每层名称以及各自协议
自上而下分别是：**应用层，传输层，网络层，链路层**

- 应用层：为应用程序提供网络接口，支持各种网络应用。协议：HTTP, SSH, SCP, FTP, SMTP, DNS
- 传输层：端到端通信，负责数据的完整性与有序性。协议：TCP, UDP
- 网络层：负责路由与寻址，通过IP地址确定数据包的传输路径。协议：IP, ICMP, ARP, RARP
- 链路层：负责数据帧的发送和转发。协议：以太网，PPP

### TCP与UDP的特点与应用
TCP与UDP作为传输层的两个协议，TCP的特点为：
1. 面向连接：通信前需要三次握手建立连接
2. 可靠传输：通过序列号、重传机制、流量控制与拥塞控制，确保数据包按序且完整到达
3. 数据流：以数据流的形式传输，不保留数据边界
4. 传输开销大：需要维护连接与执行各种控制操作
TCP适用于可靠传输的场景：
- HTTP/HTTPS：网页浏览
- FTP：文件传输
- SMTP：电子邮件传输
- SSH：安全登录

UDP特点：
1. 无连接：通信双方直接发送数据包
2. 不保证可靠性：没有可靠性机制，数据包可能丢失，乱序
3. 数据报格式：每个UDP报文独立，保留数据边界
4. 开销小：没有连接状态和流量控制的开销
UDP适用于对传输速度要求高可靠性要求低的场景，如：
- DNS：域名解析
- 视频/语音：视频会议、IP电话
- 在线游戏：实时交互性强的游戏

### 三握
首先简述三次握手的目的：确保客户端和服务器都有能力发送和接收数据，同时防止过时的重复连接造成混乱。

再简述过程：
1. SYN：客户端发送SYN，请求建立连接，并且同步序列号。此时，客户端进入SYN-SENT状态
2. SYN+ACK：服务器回应SYN+ACK，同意连接并且同步序列号。此时，服务器进入SYN-RECEIVED状态
3. ACK：客户端回应ACK，表示请求已经建立，客户端进入ESTABLISHED状态，服务器接收到客户端的ACK后，也进入相同状态，此时连接建立完成

总之，三次握手是为了建立可靠的连接，并确保双方都能正常通信。

### 四挥
目的：确保双方都已经完成数据传输，并安全地释放资源。

过程：
1. FIN：客户端发送FIN，表示希望单方面的关闭连接，不再发送数据，但是可以接收数据。此时，客户端进入FIN-WAIT-1状态
2. ACK：服务器回应ACK，同意客户端单方面关闭连接，但是仍然有数据需要发送。此时客户端进入FIN-WAIT-2状态，服务器进入CLOSE-WAIT状态
3. FIN：服务器发送完数据后，发送FIN表示服务器也要关闭连接，此时服务器进入LAST-ACK状态
4. ACK：客户端回应ACK，进入TIME-WAIT状态，等待2MSL以确认服务器接收到ACK包。进入CLOSED状态，服务器收到ACK包后也进入CLOSED状态，此时连接关闭完成

总之，四次挥手是为了安全的关闭连接，防止服务器的相关连接资源的泄漏。

### HTTP长连接和短连接的区别
短连接：
- 每次请求都建立独立的TCP连接，效率低
- 适用于请求量少或对实时性要求高的场景

长连接：
- HTTP/1.1默认，多个请求共享同一个TCP连接
- 减少连接建立次数，降低请求延迟，提高传输效率
- 适用于请求频繁的场景

### HTTP1.0、1.1、2.0的区别

HTTP/1.0：
- 每个请求使用独立的TCP连接，响应后立即关闭
- 不支持持久连接，每次请求请求需要重新建立连接，效率低
- 缺乏缓存控制机制
HTTP/1.1：
- 默认支持长连接，允许多个请求共享一个TCP连接
- 改进了缓存控制，通过Cache-Control配置详细的缓存策略
- 支持分块传输解码
HTTP/2.0：
- 采用二进制协议，解析效率高
- 支持多路复用，多个请求在一个连接上并行处理
- 引入流的概念和请求的优先级设置
- 使用头部压缩减少传输的数据量


## 数据库

### 讲一下MVCC的作用，以及它是如何实现的
先说明MVCC的作用：通过维护数据的多个版本，允许读写操作并发执行，避免了读写冲突，提高数据库的并发性能。为每个事务提供数据的快照，使多个事务可以同时读取同一行数据而不会互相干扰。

再说明实现方式：

1. 每行数据包含回滚指针与事务ID
2. undolog记录数据修改前的版本
3. 读操作将根据事务的开始时间，选择合适的版本，确保读取到的是事务开始时的数据状态
4. 写操作将更新undolog，保留数据的旧版本，直到不再有事务需要访问它


### 事务是什么？ACID？事务是如何实现的？  
先概述事务：一组操作的集合，这些操作要么全部成功，要么全部失败，保证了数据的一致性与完整性。

ACID是事务的四个性质：
1. 原子性：事务中的操作要么全部成功，要么全部失败
2. 一致性：事务执行前后，数据库的状态一致
3. 隔离性：事务之间互不影响，每个都认为当前只有自己在访问数据库
4. 持久性：事务一旦提交，结果永久保存，即使发生故障也不丢失

以MySQL为例，再说实现：
1. 通过undolog记录事务的修改，在事务失败或回滚时恢复数据，保证原子性
2. 通过约束、触发器与规则保证数据从一个一致状态转移到另一个一致状态
3. 通过锁机制与MVCC保证隔离性
4. 通过redolog记录已提交的事务操作，用来在系统故障时重放，保证持久性

### InnoDB和MyISAM的区别
1. 事务支持：InnoDB支持事务，提供ACID，而MyISAM不支持
2. 并发控制：InnoDB使用行锁和MVCC，并发性能好，而MyISAM使用表锁，并发性能差
3. 索引结构：InnoDB使用聚簇索引，主键和数据一起存储，MyISAM采用非聚簇索引
4. 崩溃恢复：InnoDB使用redolog和undolog进行崩溃恢复，MyISAM仅提供简单的修复机制，恢复能力弱
5. 外键支持：InnoDB支持外键

### MySQL是如何保证事务的
只有InnoDB提供事务，答案见“事务是如何实现的”

### MySQL底层数据结构是什么，有什么优势
B+树，其优势为：
1. 高效的范围查询：叶子节点以双链表的方式连接在一起，支持顺序遍历，优化了范围查询性能
2. 减少磁盘I/O：节点存储多个键值，使得树的高度较低，从而减少了磁盘I/O次数（可以具体展开说：极端情况下，B+树存储在磁盘中，想要获取节点就需要进行一次磁盘I/O，由于有效数据存储在叶子节点中，所以磁盘I/O的次数等于树的高度...）

### 讲一下四种隔离级别
四种隔离级别定义了事务间的程度，由弱到强分别是：
1. 读未提交（Read Uncommitted）：存在脏读问题，事务可以读取到其他事务未提交的修改
2. 读提交（Read Committed）：存在不可重复读问题，事务可以读取到其他事务提交的修改（Oracle以及大多数数据库默认）
3. 可重复读（Repeatable Read）：避免了不可重复问题，存在幻读问题，两次查询相同的范围时，得到的结果不一致（InnoDB默认隔离级别）
4. 可串行化（Serializable）：事务按顺序执行，完全隔离，避免所有并发问题，效率低

### 详细讲一下读已提交  
- 避免脏读：只能读取已经提交的数据
- 存在不可重复读问题，多次读取相同的数据可能存在不同的结果

以InnoDB为例，读已提交通过MVCC实现：
- 每次的读取操作都将生成ReadView，记录当前数据库活跃的事务ID
- 通过目标数据行的版本链，找到第一个已提交的版本（事务ID不在ReadView中）并读取

### 详细讲一下可重复读
- 避免脏读，不可重复读，读取同一数据的结果一致
- 存在幻读问题，可以读取到其他事务Insert的数据

以InnoDB为例，可重复读通过MVCC实现：
1. 事务开始时，删除ReadView，记录当前数据库活跃的事务ID
2. 每次的读取操作都将访问同一ReadView，读取已提交的数据版本

### InnoDB如何解决幻读问题？
InnoDB利用间隙锁与临建锁解决幻读。

TODO


## 常见设计模式
六大原则？

手撕快排算法
手撕工厂模式代码
手撕线程安全的单例模式
手撕智能指针 



## 其他
### 讲一下gRPC
先大致概括，传输协议与传输格式：gRPC是一个高性能，开源的远程过程调用（RPC）框架，基于HTTP/2协议与Protocol Buffers（protobuf）序列化格式。

再介绍传输方式与使用场景：支持多种编程语言，允许客户端与服务器之间通过定义好的服务接口进行通信，适合分布式系统中的微服务结构。

最后介绍高级特性：gRPC还支持双向流、负载均衡、认证和压缩等高级特性。

### gRPC是如何实现通信的


消息队列了解吗？
josn和probobuf有什么区别


使用过哪些面向对象的特性，请用你的项目来解答？

死锁是怎么产生的，怎么避免死锁
操作系统进程调度策略
如何在控制台中查看日志
进程间通信有哪些方式
用什么指令查看CPU占用率

C和C++区别
讲一下深拷贝浅拷贝，如何实现深拷贝
讲一下内存对齐
讲一下缓存优化
现在有一个shared_ptr，调用函数传递它再返回，会发生什么，说一下这个过程
一个文件中有1亿个ipv4地址，你需要将他们从小到大排序，给你的内存不足以容纳全部的地址，你会怎么做？（外部排序）

b+树结构，为什么mysql要使用b+树作为索引
inner join
一条select语句底层实现是怎样的

https的原理
TCP/IP 中 timeout 是什么原因

如何在map中根据value进行排序
他问我Vector的增长机理，以及为什么是1.5倍或2倍。

TODO：url输入后的过程