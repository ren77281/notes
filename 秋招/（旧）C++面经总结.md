```toc
```
## C++语法
### 基础知识
#### include尖括号与双引号的区别？
预处理源文件后，include会将头文件的所有内容展开
尖括号用来引用C++标准库的头文件，编译器将在预置的标准库头文件路径下搜索头文件
双引号用来引用本地头文件，编译器先在当前目录搜索头文件，找不到时再去标准头文件的路径下搜索
所以不能用尖括号引用自己的头文件，但是用双引号却可以引用标准库头文件
#### 指针常量和常量指针的区别？
`const int*`/`int const*`：常量指针，表示不能修改指针所指向的值，const修饰右边的符号（`int`/`*`)，说明该指针指向的int变量为常量（无法修改指向地址上的数据）
`int* const`：指针常量，表示不能修改指针变量的值，const修饰右边的符号（变量），说明变量是常量
#### 如何防止指针被双重删除？
1. 每次释放资源后，将指针指向空。删除空指针是安全的
2. 直接使用智能指针，利用对象的生命周期，避免手动管理内存的麻烦
#### `\n`与endl的区别
`\n`比endl速度快，打印`\n`不会刷新缓冲区
而使用endl将刷新缓冲区，确保数据的输出，但速度相对较慢
#### noexcept关键字了解吗？
C++11引入的新的异常说明符
在函数的最后声明noexcept，表示该函数不会抛出异常，如果该函数抛出异常，程序将调用std::terminate，这将导致程序的终止
同时编译器也会对noexcept函数进行优化
#### explicit关键字了解吗？&&&
用于声明构造函数和转换构造函数，以防止隐式类型转换
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/202405301146069.png)
#### 内存泄漏了解吗？
内存泄漏指的是：程序在运行过程中，因为疏忽或错误，未能释放不再使用的内存，从而失去了对这些内存的限制，造成的资源浪费
可能的情况有：
1. 堆内存泄漏
  - 使用`new []`获取的内存，却使用delete释放
  - 申请了内存，忘记释放，或者因为错误导致释放语句被跳过
2. 如果没有将基类的析构函数定义为虚函数，使用多态时，将导致子类部分的资源泄漏。因为没有重写父类的析构函数，子类的资源不会被释放
3. 系统资源泄漏，如：处于CLOSE_WAIT状态的套接字需要调用close关闭
#### 如何避免内存泄漏？
1. 使用智能指针，但需要注意shared_ptr的循环引用问题
2. 在Linux环境下，可以使用检测工具valgrind
3. 手动在程序中添加统计功能，统计已经申请的内存与释放的内存
#### C语言中的内存分配手段有哪些？&&&
1. malloc：申请指定字节数的内存，内存中的初始值不确定
2. calloc：申请指定字节数的内存，内存中的初始值为0
3. realloc：更改已经分配过的内存长度。增加时，可能需要将数据从原内存移动到足够大的新内存上。新空间的初始值也不确定
#### new/delete与malloc/free的区别？
1. new/delete是操作符，而malloc/free是函数
2. new失败抛异常，malloc失败返回空指针
3. new在申请时，只需要指定类型，而malloc在申请时需要具体的字节大小
4. new返回的指针类型与申请类型对应，而malloc只返回空类型指针，需要进行强制
5. new在底层调用了operator new，而operator new是对malloc的封装，delete同理，所以new和malloc是调用与被调用关系
#### delete和delete[]的区别？
使用`new []`申请资源时，会申请额外的空间以保存本次申请的空间大小。使用`delete []`释放内存时，会先获取该内存块的大小，再释放完整的内存块
而delete将直接释放对应类型大小的空间，如delete a，a是一个int变量，那么delete将直接释放4字节空间
如果使用delete释放`new []`申请的资源，将导致资源泄漏
#### delete this合法吗？&&&
合法，this是指向当前对象的指针，delete一个指针当然合法
但是该对象资源必须是通过new申请的
之后也不能访问该对象的非静态成员或者使用this指针，这将导致解引用野指针/空指针
#### 堆与栈的区别？
1. 堆区比栈大，通常栈区在1M~8M之间，取决于编译器的限制。堆区可以是几十G或更大，取决于操作系统的限制
2. 堆区向高地址生长，而栈区向低地址生长
3. 堆区资源需要手动管理，通过new/malloc获取，delete/free释放，存在内存泄漏问题。栈区存储局部变量，退出函数时，自动销毁局部变量
4. 堆区资源的分配效率低于栈区，需要向内存池申请内存块，如果内存池空间不足，将调用brk()/VirtualAlloc()申请堆区资源，填充内存池，再返回内存块。其中涉及到数据结构的维护，效率较低。对于栈区资源，只需要通过栈顶/栈底指针的移动，生成函数栈即可
5. 栈区先进后出，资源的申请与释放连续，这使得栈区的内存块连续，不存在分散的空闲块。因为堆区支持动态内存管理，所以资源申请与释放不连续，内存块也不连续，极易出现零散的内存碎片
总结就是：大小，生长方向，资源申请方式/效率，内存碎片问题，
#### inline函数了解吗？
1. inline修饰函数，用于建议编译器优化，在编译期间将函数展开。编译器会根据函数调用频率，函数体大小以及内部优化策略来决定是否进行展开。总之是一种空间换时间的优化
2. 将函数展开后，能够减少创建与销毁函数栈帧的开销（压栈，传参）
3. 缺点是：代码膨胀，是否展开完全取决于编译器，并不可控
4. 若编译器决定将inline展开，那么不会将inline函数地址放入符号表。如果将inline函数的声明与定义分别实现在不同文件中，将导致源文件的链接错误
5. 通常使用inline函数代替宏，因为inline作为函数，有类型检查，能够调试，可读性高
6. 在类中声明并定义的函数，将被隐式地声明为内联函数
#### 深拷贝与浅拷贝的区别？
浅拷贝：只是拷贝对象的字面值，如果原对象拥有引用类型，那么浅拷贝产生的新对象将与原对象共享这块资源。类的默认函数的拷贝策略都是浅拷贝
深拷贝：递归地拷贝对象。如果对象存在引用类型，将访问其执行的资源，并进行浅拷贝，直到对象不存在引用类型。深拷贝将得到一个完全独立的对象
#### 内存对齐了解吗？
1. 有效对齐值：min(默认对齐数, 最大成员大小)，一般默认对齐数大小为4`#pragma pack(4)`
2. 对齐值：第一个成员对齐到0，之后的成员对齐到min(有效对齐值, 自己的大小)的倍数倍地址处。结构体成员的对齐值为：其成员的最大对齐值
3. 结构体的最终大小为有效对齐值的整数倍
大部分cpu以2的幂次方存取内存，内存对齐能够减少cpu的存取次数
如：假设cpu以4字节长度存取数据，int类型的数据存储在地址1~4处，cpu需要读取0~3，4~7的内存，再剔除无效数据
#### 原代码是如何变成可执行文件的？&&&
1. 预处理：头文件展开，宏替换，删除注释，条件编译，处理`#pragma`。.c->.i
2. 编译：生成汇编语言。包括词法分析（识别括号、数字、标点），语义分析（考虑类型声明、匹配与转换），语法分析（生成语法树）。.i->.s
3. 汇编：生成机器可执行的01代码，由汇编文件生成目标文件。.s->.o
4. 链接：调用链接器ld将多个目标文件以及所依赖的库文件链接起来，生成可执行文件。包括了符号解析，地址分配，重定位等
#### 什么是大端序，小端序？如何确定一台机器是大端机还是小端机？&&&
小端序：在一个多字节变量中，低地址处存储低位数据，高地址处存储高位数据
大端则相反：低地址存储高位数据，高地址存储低位数据
创建一个多字节变量，如int，并赋予每个字节不同的值，将该变量强转成单字节类型，打印强转后的数据。打印结果为该变量的低地址数据，如果存储低位数据，说明当前机器是小端机，反之则是大端机
#### extern "C"有什么用？&&&
通过`extern "C" {}`声明的代码将被编译器当作C语言代码处理，可以解决C++与C之间的链接问题
用于C++和C有着不同的符号修饰规则，如函数重载，使用`extern "C"`处理代码，使这些符号具有C的链接规范，使得C++能够调用C的函数
通常使用`extern "C"`声明、定义C函数，或者`include`C的头文件
#### 多字节字符如何编码？&&&
C语言采用ASCII编码集，使用了7位ASCII码表示了所有英文字符。不同国家有不同的编码格式，为了统一字符，我们将所有字符放入Unicode字符集中
Unicode包含了一百多万个字符，每个字符对应一个码点。为了兼容ASCII，其中0-127的码点与ASCII相同，码点的范围是`U+0000`到`U+10FFFF`
为了适应不同需求，存在三种不同的Unicode编码
1. UTF-8：变长编码，使用1-4字节表示字符
2. UTF-16：使用2字节表示`U+0000`到`U+FFFF`内的字符，其他字符使用4字节表示
3. UTF-32：统一使用4字节表示所有字符
#### UTF-8是如何实现变长编码的？&&&
1. 对于单字节字符，第一位为0，后面7位为该字符的码点
2. 对于多字节字符（假设x字节），第一个字节前x位为1，第x+1位为0，后续字节的前两位为10。剩下的位用来表示该字符的码点
#### nullptr，NULL，0，(void*)0的关系？
- C语言中，NULL是`(void*)0`的宏定义。并且支持将(void\*)隐式转换成int或int\*
- C++中，NULL是`0`的宏定义。C++则不允许(void\*)到任何指针类型的隐式转换，更不允许转换成其他类型，如int
不管在C还是C++中，将0作为参数，能够调用类型为int的函数，也能调用类型为`void*`或是任意指针类型的函数，所以0具有二义性，可以是指针类型也能是整数类型
由于C语言允许指针类型的隐式转换，所以NULL也具有二义性，容易引起类型安全问题
所以C++使用nullptr代替了NULL，nullptr的类型为nullptr_t，既不是指针类型也不是整数类型。nullptr是一个编译期常量，可以被隐式转换成任意类型指针
### 类与对象
#### C++的class和struct的区别？
1. class的默认成员属性为private，而struct则为public
2. class的默认继承属性为pricate，而struct则为public
3. 在项目的开发中，通常使用struct标识简单的结构，而使用class表示复杂的结构
#### 如何理解this指针？
1. this指针是成员函数的一个隐式参数，位于参数列表的第一个，指向调用该函数的对象
2. 当对象调用非静态成员函数时，编译器会将对象的地址传入this参数。成员函数将通过this指针访问对象数据
3. this指针的类型为className \* const this，指针常量，无法修改this变量的内容，同时不能对this变量取地址
#### 类的静态成员函数特点？
1. 静态成员函数不依赖于对象，它属于整个类。与普通成员函数的区别就是没有隐藏this参数，所以我们可以通过类的成员调用静态成员函数，还能通过类名直接调用
2. 静态成员函数不能访问非静态成员。对于非静态成员变量来说，由于静态成员函数没有this指针，不与对象绑定，所以无法确定将要访问哪个对象。对于非静态成员函数来说，其拥有隐藏的this指针，而静态成员函数没有this指针，所以无法访问
3. 静态成员函数可以被覆盖，子类能够重写父类的静态成员函数
#### 如何定义只能在堆上创建对象的类？&&&
进程地址空间中，有三个区域能存储对象：栈区，堆区，静态区
只能在堆上创建的类：
将类的构造函数声明为私有，定义一个静态成员函数，该函数调用new在堆上创建对象，并返回该对象的地址。同时需要禁止拷贝/移动构造，防止在栈区、静态区中创建对象，此时只能通过该静态成员函数创建该类的对象
#### 构造函数和析构函数中可以抛异常吗？！！！

#### 编译器什么时候会生成默认构造函数？！！！


### 继承与多态
#### 什么是多继承问题？如何解决菱形继承问题？&&&
多继承指的是：子类从多个父类继承属性和方法。可能导致的问题有：菱形继承，命名冲突
菱形继承：D继承于B，C，而B，C继承于A。此时D中包含了两份A的成员，导致了数据冗余。访问D中的A成员时，编译器无法确定访问的是通过B继承的A成员还是通过C继承的A成员
总结就是：数据冗余和二义性
C++可以通过虚继承解决菱形继承问题。在继承层次中，虚继承能够确保间接继承的共同基类只有一个实例
编译期间，编译器将生成一张虚基类表，其存储了指向虚基类对象的偏移量。每个通过虚继承创建的类都有一个虚基类表指针，程序将根据虚基表中的信息来确定如何访问虚基类部分
编译器处理D的定义时，会发现B与C都虚继承与A，那么编译器会合并虚基类A的对象，并使B和C的虚基表指向这部分对象
但是虚继承带来了额外时间，空间成本，也增加了程序复杂性
#### 什么是多态？
同一个操作作用于不同对象，产生不同的行为。多态分为两种
- 编译时多态：通过重载实现，在编译期间根据函数参数数量、顺序、类型来决定调用的函数
- 运行时多态：通过继承与虚函数实现，在运行期间通过虚函数表，确定要调用的函数
#### 如何理解虚函数？
1. 虚函数是一种特殊的成员函数。用来实现多态，在父类中声明成员函数为虚函数，并在子类重写虚函数。使用父类指针/引用接受子类对象，用父类指针/引用调用虚函数，将执行子类的虚函数
2. 虚函数是一种动态绑定，运行时通过虚表指针，找到虚函数表，再根据函数名确定函数调用的版本。但相比于静态绑定，动态绑定占用了更多时间与空间，换来了更灵活的程序
#### 虚函数是如何实现的？
虚函数通过虚函数表实现
当一个类中存在虚函数时，其内存布局的第一个变量将是一个虚表指针，指向虚函数表，该表存储了虚函数对应的地址
使用父类指针/引用调用虚函数时，将通过对象的第一个变量：虚表指针，找到虚函数表，再找到虚函数对应的地址，最终执行该虚函数
子类不重写虚函数，虚函数表与父类相同
子类重写虚函数时，实际上是用自己的虚函数地址，覆盖虚表中的原地址。所以在原理层面上，重写也称为覆盖
#### 什么是纯虚函数？
1. 只声明不定义的函数，被称为纯虚函数。通常出现在基类中，在函数声明的最后加上`= 0`
2. 拥有纯虚函数的类被称为抽象类，无法实例化抽象类对象，只能继承抽象类，并完成对纯虚函数的重写，才能实例化纯虚函数的派生类
3. 也可以理解为纯虚函数是一种强制重写
4. 主要作用是定义接口，提供抽象基类，实现多态和代码的灵活扩展
#### 一个对象最多只能有一个虚函数指针吗？
同一类中的虚函数都将被存储在同一张虚表上，所以一个对象确实最多有一个虚函数指针
#### 友元函数能作为虚函数吗？
C++中，只有成员函数才能被声明为虚函数，而友元函数不是成员函数，它一定不具有当前类的this指针。它可以是全局函数，其他类的成员函数。友元函数只是能够自由地访问类的所有成员
#### 虚函数可以声明为inline吗？
inline函数将在编译期间被展开，也就是需要在编译期间就确定实际调用的函数。而虚函数的调用却是动态绑定的，也就是在运行期间才确定调用的实际函数。两者的机制冲突，所以虚函数不能被声明为inline
#### 函数模板可以是虚函数吗？
函数模板在编译期间根据模板参数进行实例化，和inline一样，需要在编译期间确定实际调用的函数，而虚函数的调用需要在运行期间确定。两者冲突，所以函数模板无法声明为虚函数
#### 没有虚函数表，如何实现多态？
1. 使用函数指针。父类的定义类型为function成员，子类的构造函数中，将自己的函数初始化父类的function成员
2. 在父类中创建标记，根据不同的标记调用不同的函数
### 模板
#### 函数模板是如何实现多态的？
函数模板在编译期间通过模板参数进行实例化，编译器会根据不同的模板参数实例化不同的函数，只要数据支持函数模板中所有的操作。实例化在编译中完成，实际上是一种静态多态
### C++11及以后的版本
#### C++11有哪些特性？
初始化列表，右值引用，default与delete，lambda表达式，auto关键字，智能指针，emplace，包装器、bind函数绑定器
#### 智能指针有哪些？区别是什么？
智能指针是RAII（资源创建即初始化）的一种实现，具体是通过对象的生命周期来实现资源的创建与销毁。智能指针存在一个问题：多个智能指针指向相同资源时，如何管理资源？
不同智能指针解决该问题的方法不同
auto_ptr：C++早期的失败设计，资源管理权转移。调用拷贝构造与赋值重载函数时，直接进行指针的交换。这将导致无法使用交换后的智能指针，开发成本增加
unique_ptr：通过delete显式删除拷贝构造与拷贝赋值函数
shared_ptr：通过引用计数的方式，实现拷贝构造与赋值重载。构造函数将创建一个计数器并将其赋值为1，拷贝与赋值函数，将增加计数器的值。析构函数将减少计数器的值，直到计数器的值为0时，才会进行资源释放
但是将shared_ptr作为成员时，可能引起循环引用，进而导致资源泄漏。如：双链表
使用weak_ptr作为成员，weak_ptr不会增加shared_ptr的引用计数，而与shared_ptr共享资源，能够避免循环引用的问题
#### 智能指针的缺点？
1. 存在循环引用，以及非shared_ptr存在所有权的问题
2. 相比原生指针更消耗cpu资源（时间、空间）
#### 给两个线程同时传入shared_ptr的引用，将导致什么问题？
1. 竞态条件：并发环境中，没有对共享数据进行访问控制。多个线程同时对共享数据的访问修改，结果取决于线程的执行顺序。可能导致数据不一致，最终结果是错误，不可预测的。这是一种线程安全问题
2. 悬空指针：静态条件下，可能发生的一种情况：一个线程释放/重载了shared_ptr，另一个线程读取shared_ptr，将导致悬空指针
#### C++11之后的版本，了解哪些新特性？
1. C++14：泛型lambda，std::make_unique，返回类型推导，二进制字面量
2. C++17：结构化绑定，if和switch的初始化语句，std::optional，std::string_view
3. C++20：协程，概念和约束，范围库
#### 右值引用和移动构造是什么？&&&
右值引用：用于绑定右值，通过右值引用定义的变量是左值。本来将被销毁的右值的生命周期将被延长为新变量的生命周期。右值引用通常与移动构造/移动赋值使用，用来避免资源的深拷贝，减少复制次数
移动构造：资源管理权的转移。在浅拷贝的基础上，将被移动的对象的引用类型置空，使得原对象不再持有资源。减少了深拷贝带来的性能消耗，避免资源浪费和重复分配
#### 什么是万能引用？&&&
使用模板时，为模板变量T加上右值引用的符号，这样的类型就是万能引用
```cpp
template <class T> 
void test(T&& x);
```
万能引用能接收任意类型的对象。通常与完美转发和移动构造一起使用，实现移动语义
#### 完美转发了解吗？&&&
使用万能引用接收任意类型的参数后，将其转发给其他函数，并保持其值类别和const属性
1. 能够精准地调用函数
2. 避免不必要的复制操作
3. 支持移动语义，允许以右值引用的方式转发参数，从而调用移动构造或者移动复制操作，提高性能
（使用万能引用接收右值时，右值将被折叠为左值）
```cpp
#include <iostream>
#include <utility> // 包含 std::forward

// 接受任意类型的参数并转发给其他函数的模板函数
template<typename T>
void wrapper(T&& arg) {
    // 在这里调用其他函数，并使用完美转发将参数转发给它
    other_function(std::forward<T>(arg));
}

// 接受左值引用参数的函数
void other_function(int& x) {
    std::cout << "Lvalue reference: " << x << std::endl;
}

// 接受右值引用参数的函数
void other_function(int&& x) {
    std::cout << "Rvalue reference: " << x << std::endl;
}

int main() {
    int x = 42;
    // 使用左值调用 wrapper 函数
    wrapper(x); // 输出：Lvalue reference: 42
    // 使用右值调用 wrapper 函数
    wrapper(123); // 输出：Rvalue reference: 123
    return 0;
}
```
#### 引用折叠的规则？完美转发是如何实现的？
如果有一个变量的类型为“引用的引用”，其中只要有一个左值引用，最终该变量的类型为左值引用，否则该变量的类型就是右值引用
## 操作系统
### 基础工具
#### vim编辑器有哪些模式，如何使用？
命令模式，输入模式，命令行模式
一启动vim，默认进入命令模式。命令模式下，敲击键盘将被识别为命令，常用命令：
- i：进入输入模式
- dd：删除整行
- yy：复制整行
- p/P：粘贴内容到光标上方/下方
- u：撤销操作
- Ctrl+r：撤销上一次撤销
输入模式：可以进行正常的文本操作，按`Esc`退出并进入命令模式
命令行模式：在命令模式中按下`:`进入命令行模式，常用命令有`wq`保存并退出，`q!`强制退出
### 进程，线程与协程
#### 虚拟内存空间是什么？有什么作用？&&&
与虚拟内存空间相对的是物理内存空间
系统为正在运行的进程分配地址空间，进程通过虚拟地址访问地址空间，进而修改数据。而虚拟地址将被页表转换成物理地址，进程对虚拟内存空间的修改，实际上是对物理内存空间的修改
1. 虚拟内存空间使得进程以同一方式看待内存，而不用关心物理空间的情况，将进程与物理空间解耦，同时也保护了物理空间，提高了系统安全性
2. 访问虚拟内存的某块空间时，只需要物理空间存在相应的页即可。所以系统可用按需加载程序，提高了程序的启动速度与内存的使用率
3. 可用使不同进程的虚拟空间映射相同的物理空间，如动态库的链接、使用共享内存进行进程通信，都是基于虚拟空间实现的
#### cpu调度进程的方法？
1. 先来先服务（FCFS）：根据进程的递达顺序进行调度，可能会导致长进程阻塞短进程
2. 短进程优先（SJF）：优先执行估计运行时间短的进程，能够最小化平均等待时间，但需要对运行时间进行估计
3. 优先级调度：根据进程的类型以及重要性赋予每个进程优先级，优先级高的进程先执行
4. 时间片轮转：所有进程轮流使用cpu，每个进程使用固定长度的cpu时间片，然后将cpu让给下一进程
#### 当进程正在读写文件时，文件被文件管理员删除了，会出现什么情况？
Linux中，文件的删除为引用删除，引用计数为0时，系统才会删除磁盘上的文件资源
每个文件有两个引用计数器，`i_count`表示当前使用者数量，为内存引用计数器。`i_nlink`表示介质连接数量，为磁盘引用计数器。只有当两个计数器的值都为0时，系统才会从磁盘中删除这个文件
当进程正在读写文件时，`i_count`一定不为0，就算`i_nlink`为0，系统也不会删除该文件
所以进程可以正常对文件进行读写，如果该进程是文件的最后一个引用，那么进程退出时，文件将被删除
#### 可执行文件的内存分区是什么样的？运行时程序的内存分区又是什么样的？&&&
可执行文件的内存分区：
Text段：存储程序的机器代码，即编译生成的二进制指令
Data段：存储初始化全局变量和静态变量（定义的同时进行初始化的变量）
BSS段：存储未初始化的全局变量和静态变量（只定义不初始化的变量）
程序运行时，系统将可执行文件从磁盘加载到内存，并创建额外的内存分区：栈区和堆区
代码区：对应Text段，存储机器代码
静态区：对应Data段和BSS段，存储全局变量和静态变量
堆区：动态分配的内存
栈区：存储函数的参数、局部变量
常量区：存储字符串常量
#### 孤儿进程与僵尸进程了解吗？&&&
对于孤儿进程：父进程退出，而它的一个/多个子进程还在运行，这些子进程将成为孤儿进程。孤儿进程会被1号进程（init）托管，由1号进程回收孤儿进程的资源，所以孤儿进程并不会对系统造成影响
对于僵尸进程：子进程结束，系统并不会释放其资源，需要父进程调用wait/waitpid接收其返回信息，系统才会释放子进程资源。如果父进程总是不调用wait/waitpid，那么该子进程将成为僵尸进程，泄漏系统pid资源，僵尸进程通过ps显示出的状态为`Z`。如果存在大量僵尸进程，系统将无法创建新的进程
#### 线程拥有哪些独立资源？哪些资源与进程共享？&&&
共享的资源有：
- 堆栈资源
- 文件描述符
- 信号机制的handler表（信号的处理方式相同）
- 当前工作目录，用户id和组id
独立的资源有：
- 线程栈
- 线程上下文（一组寄存器，线程状态，栈指针）
- 信号屏蔽字
- 调度优先级
#### 每个进程的内核空间数据都是相同的吗？&&&
大部分相同，如
- 内核自身代码与数据结构
- 设备驱动程序
- 中断处理程序
- 系统调用接口
不同：
- PCB：包含进程状态，寄存器内容，程序计数器，进程优先级
- 内核栈：每个进程在内核态运行时都会有一个独立的函数栈，用来进行系统调用，存储函数局部变量
- 内存管理数据：进程的内存管理信息，如页表
- 文件描述符表：每个有自己的一组文件描述符表，指向进程打开的文件、网络连接等
#### 线程的内核空间保存了什么？&&&
- 线程控制块TCB
  - 用于管理线程的执行状态与上下文信息
  - 包括了程序计数器PC，寄存器状态，栈指针，线程状态（阻塞，运行...），调度优先级，线程ID...
  - TCB通常保存在内核区，由操作系统管理与维护
- 内核栈
  - 线程陷入内核运行时，进行系统调用，中断处理等操作，需要使用内核栈
- 线程的运行环境
  - 如线程锁，条件变量
#### 为什么切换协程比切换线程快？&&&
协程使用线程的用户空间，并且将上下文信息保存在用户空间，所以切换协程不用陷入内核，进行系统资源管理和安全检查，无系统调用开销
也就是说，我们在线程的**用户空间**中加入了调度器层，用来隔离内核空间，实现了类似操作系统的调度策略，使cpu与内核空间绑定，显著减少了cpu的调度次数。而用户空间则被划分为粒度更细的协程，由用户自行调度
### 多线程
#### 没有future之前，C++如何实现异步调用？
主要通过回调函数与多线程实现
#### I/O多路复用的原理？
1. 程序向操作系统注册一系列的文件描述符（可能是套接字I/O，也可能是其他文件I/O）及其对应事件（如读/写）
2. I/O线程阻塞式等待事件发生，可能被就绪事件唤醒，也可能由于超时被定时器唤醒
3. 一旦事件发生，I/O线程将依次处理所有就绪事件，对于每个就绪事件执行I/O操作
4. 重复以上过程
#### 锁的种类？
1. 互斥锁：
2. 自旋锁：
3. 递归锁：
4. 读写锁：
5. 条件变量：
6. 信号量：
#### 介绍一下自旋锁？
自旋锁用来实现多线程环境下的同步，能够避免互斥锁切换线程上下问带来的开销，提高系统效率
获取自旋锁失败后，线程不会陷入阻塞，而是陷入忙等待：不断检查锁是否被释放，这将占用cpu时间。所以我们应当避免线程长时间使用线程锁，导致其他线程的忙等待
所以自旋锁适用于保护短时间的临界资源访问操作
不建议在单cpu系统中使用自旋锁：若线程获取自旋锁失败，该线程将忙等直到耗光cpu时间。在这期间，占有自旋锁的线程无法被cpu执行，那么线程的忙等其实是在浪费时间
#### 互斥锁和自旋锁的区别？
两者的区别在于：获取锁失败后，表现的状态
当线程获取互斥锁失败后，将陷入阻塞状态，直到锁被释放。线程阻塞时，不会消耗cpu事件，所以互斥锁适用于保护长时间访问的临界资源
当线程获取自旋锁失败后，将陷入忙等待状态，不断地检查锁是否被释放。由于线程不会陷入阻塞，所以将消耗cpu时间。所以自旋锁适用于保护短时间访问的临界资源，以避免切换上下文所带来的开销
#### 死锁的四个条件？&&&
1. 互斥条件：资源只允许被一个线程独占
2. 请求与保持：线程在请求其他资源时依然保持着资源，其他线程无法访问被保持的资源，直到该线程请求成功
3. 不剥夺条件：资源只能由线程主动释放，不能被其他线程夺取
4. 循环等待条件：存在一条环形的资源请求链，线程T1请求T2保持的资源，T2请求T3保持的资源...Tn请求T1保持的资源
只有以上四个条件同时成立，才会构成死锁。只要破坏其中任何一个条件，就能避免死锁。相应的破坏方法如下
1. 减少资源的独占情况，如使用读写锁
2. 资源预分配，资源释放策略（先释放资源再请求资源）
3. 无
4. 资源有序分配，对资源进行编号，如线程已经持有1号资源，那么它只能请求编号大于1的资源
## 网络
### 基础知识
#### 网络体系结构是什么样的？每层的作用是什么？
自顶向下为：
1. 应用层：为用户和应用程序提供网路服务，如HTTP，FTP，SCP
2. 传输层：负责两个主机中的进程通信，也就是端对端的数据传输。主要使用TCP（面向连接，提供可靠的交付）和UDP（无连接，提供尽可能的交付）
3. 网络层：负责数据在不同主机间的路由，使用IP协议，将IP数据报传输到指定主机
4. 数据链路层：负责路由转发能力，在相邻主机间传输帧数据，也就是完成路由中的“下一跳”
### 传输层
#### TCP三次握手与四次挥手了解吗？&&&
三次握手
1. 客户端发送SYN给服务器，请求通信，同时告知对方自己的**初始化序列号**
2. 服务器返回SYN：允许与客户端的通信。返回ACK：对方的SYN被成功接收，同时也告知对方自己的初始化序列号
3. 客户端返回ACK：确认接收对方的SYN
4. 服务器将客户端信息放入全连接队列中，使用accept将取出队头客户端并建立通信套接字进行通信
5. `int listen(int sockfd, int backlog)`的第二个参数 + 1表示全连接队列的长度，队列溢出时，服务器将发送RST拒绝通信
四次挥手：
1. 客户端发送FIN，请求关闭连接，进入FIN_WAIT_1
2. 服务器返回ACK响应FIN，进入CLOSED_WAIT状态，此时客户端单方面地关闭与服务器的连接（服务器如果不关闭套接字，将造成资源泄漏）
3. 客户端接收ACK后，进入FIN_WAIT_2
4. 服务器发送FIN，请求关闭连接，进入LAST_ACK状态
5. 客户端发送ACK，响应对方的ACK，等待2MSL后，进入CLOSED状态
6. 服务器接收ACK后，进入CLOSED状态
#### 为什么要进行三次握手？&&&
1. 同步序列号
2. 确认双方的接收发送能力
3. 避免网络延迟或数据包重传导致的重复连接与资源浪费（客户端将忽略已经连接的服务器发送的SYN-ACK）
#### 序列号有什么用？！！！
#### 如何阻止SYN泛洪？！！！


#### 为什么要进行四次握手？！！！
#### 部署TCP服务器的步骤？
1. socket()：创建监听套接字
2. bind()：将套接字绑定指定的IP与端口号
3. listen()：使套接字进入监听状态，客户端能够与客户端进行握手
4. accept()：握手成功后，客户端信息将被存储到全连接队列中，使用accept将取出第一个客户端信息，并建立服务套接字用于通信
#### TCP拥塞控制的实现方式？
1. 慢启动：一开始的拥塞窗口大小（cwnd）为较小的数，随之接收到ACK包的次数增加，cwnd指将数级别增长（通常乘以2），直到达到阈值
2. 拥塞避免：达到阈值后，cwnd增长速度放慢，转为线性增长（每次增长一个MSS，最大报文大小）
3. 快重传：收到三个相同ACK包后，可以认为数据包丢失，将立即重新发送数据包，而不是等待超时
4. 快恢复：快重传后，拥塞阈值将被设置为当前窗口的一半，cwnd将被设置为比阈值稍大的数
5. 发送**超时重传**后，cwnd将被设置为1，拥塞阈值将被设置为当前窗口的一半，重新开始慢启动
#### 滑动窗口的大小最大为多少？
TCP协议格式，使用了16bit来表示滑窗大小，所以最大为$2^{16} - 1$
#### 为什么TIMEWAIT状态后，需要等待2MSL才会进入CLOSED状态？
1. 需要确认最后一次挥手的可靠性：ACK包的成功送达。假设ACK包发送超时，对方将重新发送FIN，最多需要2MSL的时间。再次接收到FIN后，表示ACK包的丢失，需要重新发送。如果在2MSL内没有收到对方的FIN，说明ACK包已经成功送达，可以关闭连接（但重发的FIN包依然可能丢失，此时对方在重发一定次数/经过一段时间将自动关闭此次连接，并不会造成永远的资源泄漏）
2. 这段时间内，网络设备和操作系统将丢弃残留的旧数据包，防止它们对新连接产生影响
#### TCP连接期间，突然拔掉网线，将发生什么？
1. TCP无法立即检测到物理层面的断网 
2. 未发送的数据将无法发送，传输中断
3. 对于双方：已发送但未确认的数据，将导致TCP的超时重传
4. 重传超过一定次数，将认为对方断开连接，连接将被关闭
#### 不开启TCP的keep-alive，将发生什么？
1. 如果双方长时间不通信，那么该连接可能被路由器或防火墙关闭，看似还是建立的连接，其实已经断线
2. 如果继续发送数据，将导致重置错误（RST），此时需要重新建立连接
3. 如果应用程序有心跳检测机制，将触发应用程序的超时机制，进行超时处理

### 应用层
#### DNS解析过程是什么样的？
1. 浏览器请求：浏览器向本地DNS服务器发送域名解析请求（本地服务器在局域网中缓存常用域名的解析结果）
2. 本地DNS服务器：若本地DNS服务器的缓存中没有对应记录，则向递归DNS服务器发送查询请求
3. 根服务器：递归DNS向根服务器发送查询请求，根服务器将返回该顶级域名对应的顶级域名服务器地址
4. 顶级域名服务器：将返回负责该域名的权威DNS服务器地址
5. 权威域名服务器：将返回该域名对应的IP
6. 递归DNS服务器将IP返回给本地DNS服务器，本地服务器缓存解析结果并将IP返回给浏览器
#### http和https的区别？
1. 安全性：https引入TLS，SSL加密层，所有传输都是加密传输，而http的传输未加密，不安全
2. 性能：由于https的加解密过程，性能稍微慢于http
3. https的加密层需要使用SSL/TLS证书来建立连接
4. 端口：http的默认端口为80，https的默认端口为443
#### https握手的过程？
1. 客户端发送https请求，请求建立SSL连接
2. 服务器返回带有服务器公钥的SSL证书
3. 客户端验证证书，使用服务器公钥加密对称密钥，这个对称密钥通常由浏览器生成
4. 服务器接收后，使用自己的私钥解密，获取客户端的对称密钥
5. 之后的通信将基于该对称密钥进行加密
#### 长短连接的区别
1. http 1.0默认采用短连接，通信过程中只进行一次数据传输，传输完成后就关闭连接。每次请求都要进行三次握手，四次挥手，开销和延迟大，但实现简单。适用于传输频率较低，数据量不大的场景
2. http 1.1默认采用长连接，在报头中添加`Connection:keep-alive`头部实现。可以进行多次数据传输，直到明确关闭连接或者超时。减少了频繁建立关闭连接的开销，提高传输效率，但是占用更多系统资源（可能导致资源泄漏），实现相对复杂（心跳维护）。适用于数据库连接，即时消息等场景

## STL
### 六大组件
#### STL六大组件是什么？之间有什么关系？&&&
1. 容器：用来存储和管理数据，每种容器都有自己的性能特点
2. 算法：STL提供了常见的算法，这些算法可以对容器中的数据进行操作，如排序，增删改查等
3. 迭代器：用来遍历，访问容器内的数据。提供了统一的方法访问不同的容器，而我们不需要知道容器的内部实现
4. 函数对象：能够像函数一样访问的对象，重载了`operator()`方法。通常用于自定义算法行为，如自定义排序规则
5. 适配器：将一种接口转换成另一种接口的组件，如容器适配器stack、queue，函数适配器bind。通过屏蔽原接口的某些行为，或是设置默认行为，实现一个新的接口
7. 空间配置器：用于分配和释放对象的内存，所有容器都需要通过空间配置器分配和释放对象。默认的空间配置器为`std::allocator`，我们可以自定义空间配置器，控制内存的管理
### 迭代器
#### 迭代器的类型有哪些？&&&
1. 输入迭代器(Input Iterator)
2. 输出迭代器(Output Iterator)
3. 前向迭代器(Forward Iterator)：单向链表
4. 双向迭代器(Bidirectional Iterator)：双向链表
5. 随机访问迭代器(Random Access Iterator)：vector
#### 迭代器失效了解吗？如何避免？&&&
迭代器失效：
1. 迭代器成为野指针
2. 虽然不是野指针，但发生了意义变化
对于数组容器，**删除，插入**操作将使得当前迭代器之后的所有迭代器失效（删除操作使迭代器失去意义）
如果插入操作触发了**扩容**，那么所有迭代器都将失效，因为这涉及到内存的重新分配
insert和erase操作都将返回操作后的下一个有效迭代器

对于链式容器，因为使用不连续内存存储数据，所以只有**删除**操作只会使当前迭代器失效
接收erase的返回值或者使用`erase(iter ++ )`，以解决迭代器失效的问题

对于树形容器，只有删除操作会使当前迭代器失效。
接收erase的返回值或者使用`erase(iter ++ )`，以解决迭代器失效的问题
### vector
#### vector容器是如何实现的？线程安全吗？
所有STL容器都是线程不安全的
vector底层采用动态数组实现，底层为三个指针
分别是：指向数组开始的指针，指向数组结尾的指针，指向有效数据结尾的指针
对vector添加数据时，如果实际大小等于容量（无法存储更多数据），将触发vector的扩容操作。一般情况下，新的容量将为原来的2倍或者1.5倍（GCC2倍扩，MSVC1.5倍扩）。接着将原vector的数据拷贝到新vector，并交换新旧vector，利用新vector为局部变量的特性，让其自动释放原空间
### map
#### map可以使用struct作为key吗？&&&
STL的底层结构为红黑树，红黑树作为二叉搜索树，需要满足可比性，如果struct之间可以进行比较，那么struct就能作为map的key
STL的具体实现中，使用`<`进行key值的比较，所以我们只需要重载struct的`<`运算符即可（注意重载函数的最后需要加上const，表示该函数不会修改成员数据，使得常量对象也能够调用）
## 数据结构与算法
### 线性表
#### 谈谈数据结构中的数组？&&&
数组作为线性表的一种，使用一段连续的空间存储一组相同类型的数据
1. 数组中所有元素的数据类型相同
2. 数组的存储连续
3. 下标从0开始
访问数组的时间复杂度为$O(1)$，直接通过下标访问，本质是对数组的第一个元素地址进行+操作
但是插入和修改的时间复杂度为$O(n)$

### 树
#### 概念：满二叉树，完全二叉树
满二叉树：每个节点要么有两个子节点，要么没有子节点
- 所有非叶子节点都有两个节点
- 所有叶子节点位于同一层
完全二叉树：
- 除了最后一层，剩下的树为满二叉树
- 最后一层的节点靠左排列，且连续
#### 二叉搜索树的性质有哪些？&&&
1. 有序：对于任意节点，其左子树所有节点小于当前节点，右子树所有节点大于当前节点
2. 可比：节点之间支持比较
3. 唯一：为了使搜索，插入，删除的逻辑能够正确执行，不存在重复值
4. 递归：任意节点的左右子节点也满足以上性质
但缺点是：无法保持平衡，插入的数据接近有序时，将退化为单支树
#### 红黑树的性质有哪些？&&&
红黑树保证：最长路径的长度不超过最短路径的两倍，属于一种弱平衡树，在节点相同的情况下，AVL树的高度低于红黑树。但红黑树的旋转次数少于AVL树，在插入，删除操作较多时，推荐使用红黑树
1. 满足二叉搜索树的所有性质
2. 每个节点非红即黑
3. 根节点为黑
4. 叶节点（NIL节点）为黑
5. 如果一个节点为红，那么其子节点为黑
6. 对于非叶子节点，到所有叶子节点路径上的黑节点数量相同
NIL节点指向空，不存储有效数据，在红黑树中作为占位符使用。为了简化插入和删除算法的逻辑，有助于保持红黑树的性质
应用：STL的set，map底层为红黑树，Linux的epoll采用红黑树管理sockfd
#### AVL树的性质有哪些？&&&
1. 满足二叉搜索树的所有性质
2. 每个节点存储平衡因子，表示左右子树的高度差
3. 平衡因子不超过1，即左右子树的高度差不超过1
#### 如何通过前序和中序遍历确定二叉树？&&&
[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked)
利用前序遍历，我们能确定根节点
利用中序遍历，我们能知道根节点左右子树的节点数量，假设左子树有x个节点，右子树y个节点
利用前序遍历，根节点在前序遍历为第1个元素，那么第2个元素和第x+1个元素分别为根节点的左右子节点
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/202405311304774.png)
### 堆
#### 小堆的插入与删除过程？
堆的底层使用线性表实现，父节点通过`(下标 - 1) / 2`访问，左右节点通过`下标 * 2 + 1 / 2`访问
插入时将数据放到数组最后。接着进行比较：若当前元素小于父节点，则两者交换，直到自己大于父节点
删除时，将根节点与最后一个节点进行交换，数组大小 - 1。将根节点向下调整：比较自己是否小于两子节点的较大值，如果大于，则将自己与两子节点的较小值交。直到条件满足
### 哈希表
#### 哈希表的原理？
哈希表是一种高效查找与存储数据的结构，以键值对的方式进行存储
1. 通过一个哈希函数，将键映射到数组中的一个位置（指向某个哈希桶），理想的哈希函数应该使哈希桶元素数量尽可能均匀
2. 哈希桶：哈希表使用数组实现，数组的元素被称为哈希桶，哈希桶存储一个或多个数据，取决于解决哈希冲突的方法
3. 哈希冲突：不同的键值可能映射为相同的哈希值，这叫做哈希冲突。大多数情况下，采用链地址法解决哈希冲突，此时的哈希桶为一张单链表，存储相同哈希值的元素值
4. 负载因子：哈希表元素数量于哈希桶数量的比值。超过一个阈值时，将对哈希表进行扩容与重新哈希
#### 解决哈希冲突的方法？
1. 开放定址法（闭散列），容易导致“你占用我的，我占用他的”
线性探测：往后线性地找空位置
二次探测：往后$2^k$地找空位置
2. 链地址法（开散列），查找效率近似$O(1)$
冲突时，将节点挂在链表下（哈希表）
3. 再哈希
### 排序
#### 稳定排序有哪些？
稳定排序：相同的元素顺序不会因为排序而改变
冒泡，插入，归并
#### 快排如何实现？&&&
选择区间中的一个数x
使用双指针从两端向中间走，使得x的左边的数小于x，右边的数大于x
然后以指针停下的位置为分界点，分成两个子区间，重复以上过程
直到区间长度为1，不用再划分子区间
## 数据库
### 基本概念
#### 关系型数据库与kv型数据库的区别
1. 关系型数据库以表的形式存储数据，数据行之间可以存在着关联，如一对多，一对一，表之间可以存在约束关系。支持复杂查询与事务，同时也支持ACID特性。适用于强一致性、事务支持、复杂查询的应用场景
2. kv型数据库以键和值的方式存储数据，数据项之间没有关联。所以读写效率高，适用与分布式系统，但不支持复杂查询
### 操作命令
#### delete，truncate，drop的区别？
1. delete：删除一行或所有行，可以与where搭配使用进行条件删除，可以回滚
2. truncate：删除所有行，保留表结构，操作速度快，可以回滚
3. drop：删除整个表，包括表结构与数据，不可回滚
#### 如何删除自增字段？
不建议删除自增字段，这可能影响现有的数据与逻辑
删除自增属性：`alter table talbe_name modify 自增字段名 int`，这行命令能够修改自增字段的属性为int
删除自增字段：`alter table table_name drop column 自增字段名`，这个命令将永久删除自增字段
使用truncate命令将重置自增字段的值，而使用delete命令不会重置

### 索引
#### MySQL中有哪些常见的索引？
1. 主键索引（聚簇索引）：主键索引唯一标识数据行，且不允许重复
2. 唯一键索引：唯一标识数据行，只能有一个，且不允许重复
3. 普通索引：用于加快索引速度的基本索引
4. 组合索引：在多个列上创建的索引，用于多条件查询优化
5. 全文索引：常用倒排索引实现（将建立包含文本所有单词的索引），对文本内容进行索引，用于全文搜索、模糊搜索、近似搜索
### 事务
#### 事务的特性？
1. 原子性：事务是最小的执行单元，不可再分。要么执行完事务，要么完全不执行
2. 一致性：执行事务后，数据库将从一个一致性状态切换为另一个一致性状态
3. 隔离性：事务之间互相隔离，多个事务并行执行时，不应该互相干扰
4. 持久性：事务一旦提交，修改将被永久保存到数据库中，就算数据库崩溃也不会丢失数据
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/202405280929653.png)

#### 乐观锁与悲观锁？
1. 悲观锁：假设冲突很可能发生，在数据处理过程中通过锁阻止其他用户访问数据。优点是直接地保持了数据的一致性和完整性。适用于写操作频繁的场景，如订单管理与交易系统
2. 乐观锁：用户获取数据时，系统还将提供版本号/时间戳。用户更新数据时，系统将比较版本号/时间戳是否一致，一致则允许更新，否则拒绝（版本号的更新为原子操作）。优点是不用显式加锁，提高系统的并发性能。适用于读操作频繁，写操作少的场景，如Web应用的浏览与更新
### 其他数据库
#### redis的数据结构？

#### redis的持久化机制？
1. RDB：在指定时间间隔内，生成数据集的时间点快照（定期备份，默认开启）
2. AOF：记录并优化服务器接收到的修改/更新操作，启动服务时，将重写执行这些命令以恢复数据（实时备份）