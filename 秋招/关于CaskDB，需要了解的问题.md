```toc
```
## 介绍BitCask存储模型
BitCask以类似预写日志的方式存储数据。对数据库的所有修改操作都将先以追加写的方式写入磁盘，然后更新位于内存中的索引。

查找数据时，根据key查找内存中的索引，获取完整数据在磁盘上的位置。接着只用通过一次I/O就能读取出完整的数据。

综上，无论是顺序写还是随机写，BitCask都以日志追加的方式写入磁盘，无论是HDD还是SSD，顺序写的速度都快于随机写，BitCask尽可能地压榨了底层磁盘的性能。无论是顺序读还是随机读，都只涉及了一次磁盘I/O，这使得读性能十分稳定。

综上BitCask的读写性能都十分稳定，相关的测试数据，您可以看简历给出的网址。

## 为什么磁盘的顺序写入效率高于随机写入？
**对于机械磁盘**：

读写数据时，涉及到两个机械操作：磁头寻道与盘片旋转。磁臂旋转带动磁头移动，移动到数据所在扇区的磁道。主轴电机旋转盘片，使磁头指向正确的扇区（磁头只能在不同磁道移动，也就是不能旋转扇区）。

以上的两个动作由机械控制完成，虽然可以并行操作，但最终的时间为两者中较长的时间。当磁头指向了正确的扇区，才能开始进行数据的真正传输。

而顺序写入时，数据存储在磁盘中的相邻扇区。磁头只需要沿磁道线性移动，盘片的旋转也将更快完成。总之，磁头的寻道时间与盘片的旋转延迟较小。

同时OS的页缓存（预读和回写）也会提高顺序读写的效率。

而随机写入时，数据大概率存储在磁盘中的不相邻扇区。磁头需要频繁的移动，盘片需要频繁旋转，寻道时间与旋转延迟都大大增加。

**对于固态磁盘**：

相比于顺序写，随机写造成的额外开销在于**GC**。

由于闪存的特性，SSD无法覆盖写入，更新和删除数据时，将出现无效page。写入数据却没有空闲block时，需要进行GC：清理block中的无效page，将有效page写入到预留空间中的空闲block中，以得到一块空闲block。

总之，清理block时，有效page越少，需要移动的page就越少，GC就越快。在顺序写入时，

## 小规模的I/O很慢
操作系统的I/O单位为4KB，就算你只写入1B，系统也会读取磁盘的4KB到内存中，修改1B数据后再写回磁盘。紧接着写入1B数据，磁头将重新移动到Block的起点，读取整块Block到内存。所以，读取

总之，小于4KB的读写将导致机械磁盘的磁头频繁重新移动，虽然移动速度很快，但是性能肯定不如直接读写4KB的数据。这也是为什么OS具有回写策略。
## OS的预读策略
1. **访问模式检测**：顺序访问时更倾向于预读（访问时间短，且读取的逻辑块地址连续，则认为系统在顺序读取）。
2. **渐进预读**：最初预读较少的数据量，如果预读的数据确实有用，系统将主键增加预读量。也就是说，预读的数量量是动态调整的。
3. **延迟预读**：在初始的读取请求完成后，立即预读。兼顾响应速度与预读效率。
4. **缓存命中**：基于缓存命中率，动态地调整预读数据量。
5. **系统负载**：如果内存紧张，或负载较高，系统会进行更加保守的预读。

总之就是：访问模式检测，渐进预读，延迟预读，基于内存、负载、缓存命中率动态调整预读数据量。

![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/202408241644422.png)
