[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/)
![image.png](https://raw.githubusercontent.com/ren77281/pigco-image/main/img/20230515223707.png)

首先这题一看就是没思路，唯一的切入点就是选择每个点作为根节点，此时每颗树都是不同的。
在一个序列中选择了一个数作为根节点，那么小于该数的序列将作为该节点的左子树，大于该数的序列将作为该节点的右子树。现在的问题是：这两个子序列有多少种情况？只要将两者的情况相乘，就能得到给节点作为根节点的树的数量。
而每个子序列也是一颗搜索树，要知道该序列能组成几种不同的搜索树，就要将序列中的每个树作为根节点，进行树的构建。
可以发现问题最终可以理解为子问题的求解，子问题就是：给你一个序列，请你返回所有满足搜索树条件的树的数量。而数量只和长度有关，和其中的数值无关，所以知道了一个序列的长度，就能知道满足搜索条件的树的数量。
初始条件是：长度为0和1的序列只能构建一种搜索树
状态转移：从长度为2的序列开始，以每个数字作为根节点，根据左右子序列的长度，通过递归分治求得该节点作为根节点时，搜索树的数量
最后只要把每个数字作为根节点时，搜索树的数量相加即可

所以需要从dp\[0]和dp\[1]开始推导到dp\[n]，每次的推导的结果都是将“以每个节点作为根节点”的搜索树数量相加。
```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i)
        {
            for (int j = 1; j <= i; ++j)
            {
                dp[i] += (dp[j - 1] * dp[i - j]);
            }
        }
        return dp[n];
    }
};
```